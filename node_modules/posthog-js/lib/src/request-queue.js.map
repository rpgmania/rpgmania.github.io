{"version":3,"file":"request-queue.js","sourceRoot":"","sources":["../../src/request-queue.ts"],"names":[],"mappings":"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","sourcesContent":["import { QueuedRequestOptions } from './types'\nimport { _each } from './utils'\n\nimport { _isArray, _isUndefined } from './utils/type-utils'\n\nexport class RequestQueue {\n    // We start in a paused state and only start flushing when enabled by the parent\n    private isPaused: boolean = true\n    private queue: QueuedRequestOptions[] = []\n    private flushTimeout?: ReturnType<typeof setTimeout>\n    private flushTimeoutMs = 3000\n    private sendRequest: (req: QueuedRequestOptions) => void\n\n    constructor(sendRequest: (req: QueuedRequestOptions) => void) {\n        this.sendRequest = sendRequest\n    }\n\n    enqueue(req: QueuedRequestOptions): void {\n        this.queue.push(req)\n\n        if (!this.flushTimeout) {\n            this.setFlushTimeout()\n        }\n    }\n\n    unload(): void {\n        this.clearFlushTimeout()\n        const requests = this.queue.length > 0 ? this.formatQueue() : {}\n        const requestValues = Object.values(requests)\n\n        // Always force events to be sent before recordings, as events are more important, and recordings are bigger and thus less likely to arrive\n        const sortedRequests = [\n            ...requestValues.filter((r) => r.url.indexOf('/e') === 0),\n            ...requestValues.filter((r) => r.url.indexOf('/e') !== 0),\n        ]\n        sortedRequests.map((req) => {\n            this.sendRequest({ ...req, transport: 'sendBeacon' })\n        })\n    }\n\n    enable(): void {\n        this.isPaused = false\n        this.setFlushTimeout()\n    }\n\n    private setFlushTimeout(): void {\n        if (this.isPaused) {\n            return\n        }\n        this.flushTimeout = setTimeout(() => {\n            this.clearFlushTimeout()\n            if (this.queue.length > 0) {\n                const requests = this.formatQueue()\n                for (const key in requests) {\n                    const req = requests[key]\n                    const now = new Date().getTime()\n\n                    if (req.data && _isArray(req.data)) {\n                        _each(req.data, (data) => {\n                            data['offset'] = Math.abs(data['timestamp'] - now)\n                            delete data['timestamp']\n                        })\n                    }\n                    this.sendRequest(req)\n                }\n            }\n        }, this.flushTimeoutMs)\n    }\n\n    private clearFlushTimeout(): void {\n        clearTimeout(this.flushTimeout)\n        this.flushTimeout = undefined\n    }\n\n    private formatQueue(): Record<string, QueuedRequestOptions> {\n        const requests: Record<string, QueuedRequestOptions> = {}\n        _each(this.queue, (request: QueuedRequestOptions) => {\n            const req = request\n            const key = (req ? req.batchKey : null) || req.url\n            if (_isUndefined(requests[key])) {\n                // TODO: What about this -it seems to batch data into an array - do we always want that?\n                requests[key] = { ...req, data: [] }\n            }\n\n            requests[key].data?.push(req.data)\n        })\n\n        this.queue = []\n        return requests\n    }\n}\n"]}