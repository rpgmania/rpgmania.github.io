{"version":3,"file":"config.js","sourceRoot":"","sources":["../../../../src/extensions/replay/config.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,OAAO,EAAE,WAAW,EAAE,UAAU,EAAE,SAAS,EAAE,YAAY,EAAE,MAAM,wBAAwB,CAAA;AACzF,OAAO,EAAE,YAAY,EAAE,MAAM,2BAA2B,CAAA;AACxD,OAAO,EAAE,MAAM,EAAE,MAAM,oBAAoB,CAAA;AAC3C,OAAO,EAAE,kBAAkB,EAAE,MAAM,yBAAyB,CAAA;AAC5D,OAAO,EAAE,KAAK,EAAE,MAAM,aAAa,CAAA;AAEnC,IAAM,aAAa,GAAG,oBAAoB,CAAA;AAE1C,MAAM,CAAC,IAAM,qBAAqB,GAAyB;IACvD,cAAc,EAAE;QACZ,OAAO;QACP,QAAQ;QACR,MAAM;QACN,KAAK;QACL,YAAY;QACZ,OAAO;QACP,OAAO;QACP,OAAO;QACP,QAAQ;QACR,MAAM;QACN,OAAO;QACP,KAAK;QACL,OAAO;QACP,MAAM;QACN,YAAY;QACZ,QAAQ;QACR,MAAM;QACN,QAAQ;QACR,OAAO;QACP,OAAO;QACP,gBAAgB;KACnB;IACD,aAAa,EAAE,UAAC,IAA4B,IAAK,OAAA,IAAI,EAAJ,CAAI;IACrD,aAAa,EAAE,KAAK;IACpB,UAAU,EAAE,KAAK;IACjB,qBAAqB,EAAE,KAAK;IAC5B,iBAAiB,EAAE,KAAK;IACxB,6BAA6B,EAAE;QAC3B,gEAAgE;QAChE,aAAa;QACb,oFAAoF;QACpF,6FAA6F;QAC7F,YAAY;QACZ,OAAO;QACP,UAAU;KACb;IACD,qBAAqB,EAAE,OAAO;CACjC,CAAA;AAED,IAAM,gBAAgB,GAAG;IACrB,eAAe;IACf,iBAAiB;IACjB,eAAe;IACf,QAAQ;IACR,YAAY;IACZ,WAAW;IACX,WAAW;IACX,aAAa;IACb,WAAW;IACX,qBAAqB;IACrB,cAAc;IACd,aAAa;IACb,cAAc;CACjB,CAAA;AAED,IAAM,yBAAyB,GAAG;IAC9B,UAAU;IACV,QAAQ;IACR,QAAQ;IACR,SAAS;IACT,QAAQ;IACR,MAAM;IACN,aAAa;IACb,WAAW;IACX,YAAY;IACZ,aAAa;IACb,OAAO;CACV,CAAA;AAED,iGAAiG;AACjG,IAAM,yBAAyB,GAAG,UAAC,IAA4B;;IAC3D,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,MAAA,IAAI,CAAC,cAAc,mCAAI,EAAE,CAAC,EAAE,UAAC,MAAM;;QACjD,IAAI,gBAAgB,CAAC,QAAQ,CAAC,MAAM,CAAC,WAAW,EAAE,CAAC;YAAS,MAAA,IAAI,CAAC,cAAc,+CAAG,MAAM,CAAC,CAAA;IAC7F,CAAC,CAAC,CAAA;IACF,OAAO,IAAI,CAAA;AACf,CAAC,CAAA;AAED,IAAM,uBAAuB,GAAG,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC,CAAA;AACrD,wFAAwF;AACxF,iGAAiG;AACjG,IAAM,kBAAkB,GAAG,UAAC,IAA4B;IACpD,IAAM,GAAG,GAAG,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;IACnC,IAAI,GAAG,IAAI,GAAG,CAAC,QAAQ,IAAI,uBAAuB,CAAC,IAAI,CAAC,UAAC,IAAI,IAAK,OAAA,GAAG,CAAC,QAAQ,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,EAAhC,CAAgC,CAAC,EAAE;QACjG,OAAO,SAAS,CAAA;KACnB;IACD,OAAO,IAAI,CAAA;AACf,CAAC,CAAA;AAED,SAAS,aAAa,CAAC,OAAe;IAClC,OAAO,IAAI,IAAI,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAA;AACnC,CAAC;AAED,SAAS,uBAAuB,CAC5B,OAAkC,EAClC,OAAwC,EACxC,KAAa,EACb,WAAmB;IAEnB,IAAI,UAAU,CAAC,OAAO,CAAC,EAAE;QACrB,OAAO,OAAO,CAAA;KACjB;IAED,IAAI,oBAAoB,GAAoB,CAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAG,gBAAgB,CAAC,KAAI,aAAa,CAAC,OAAO,CAAC,CAAA;IACjG,IAAI,SAAS,CAAC,oBAAoB,CAAC,EAAE;QACjC,oBAAoB,GAAG,QAAQ,CAAC,oBAAoB,CAAC,CAAA;KACxD;IAED,IAAI,oBAAoB,GAAG,KAAK,EAAE;QAC9B,OAAO,aAAa,GAAG,WAAI,WAAW,wCAA8B,oBAAoB,YAAS,CAAA;KACpG;IAED,OAAO,OAAO,CAAA;AAClB,CAAC;AAED,6FAA6F;AAC7F,IAAM,gBAAgB,GAAG,UACrB,OAA6B;;IAE7B,6DAA6D;IAC7D,IAAM,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,OAAO,EAAE,MAAA,OAAO,CAAC,qBAAqB,mCAAI,OAAO,CAAC,CAAA;IAEzE,OAAO,UAAC,IAAI;QACR,IAAI,IAAI,aAAJ,IAAI,uBAAJ,IAAI,CAAE,WAAW,EAAE;YACnB,IAAI,CAAC,WAAW,GAAG,uBAAuB,CAAC,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,cAAc,EAAE,KAAK,EAAE,SAAS,CAAC,CAAA;SACtG;QAED,IAAI,IAAI,aAAJ,IAAI,uBAAJ,IAAI,CAAE,YAAY,EAAE;YACpB,IAAI,CAAC,YAAY,GAAG,uBAAuB,CAAC,IAAI,CAAC,YAAY,EAAE,IAAI,CAAC,eAAe,EAAE,KAAK,EAAE,UAAU,CAAC,CAAA;SAC1G;QAED,OAAO,IAAI,CAAA;IACf,CAAC,CAAA;AACL,CAAC,CAAA;AAED,SAAS,YAAY,CAAC,OAAkC,EAAE,KAA6B;IACnF,IAAI,UAAU,CAAC,OAAO,CAAC,EAAE;QACrB,OAAO,OAAO,CAAA;KACjB;IACD,IAAI,QAAQ,GAAG,OAAO,CAAA;IAEtB,IAAI,CAAC,kBAAkB,CAAC,QAAQ,EAAE,KAAK,CAAC,EAAE;QACtC,QAAQ,GAAG,aAAa,GAAG,GAAG,GAAG,KAAK,GAAG,gBAAgB,CAAA;KAC5D;IACD,KAAK,CAAC,yBAAyB,EAAE,UAAC,IAAI;QAClC,IAAI,CAAA,QAAQ,aAAR,QAAQ,uBAAR,QAAQ,CAAE,MAAM,KAAI,CAAA,QAAQ,aAAR,QAAQ,uBAAR,QAAQ,CAAE,OAAO,CAAC,IAAI,CAAC,MAAK,CAAC,CAAC,EAAE;YACpD,QAAQ,GAAG,aAAa,GAAG,GAAG,GAAG,KAAK,GAAG,mCAAmC,GAAG,IAAI,CAAA;SACtF;IACL,CAAC,CAAC,CAAA;IAEF,OAAO,QAAQ,CAAA;AACnB,CAAC;AAED,SAAS,aAAa,CAAC,eAAmD;IACtE,IAAI,YAAY,CAAC,eAAe,CAAC,EAAE;QAC/B,OAAO,SAAS,CAAA;KACnB;IAED,eAAe,CAAC,WAAW,GAAG,YAAY,CAAC,eAAe,CAAC,WAAW,EAAE,SAAS,CAAC,CAAA;IAClF,eAAe,CAAC,YAAY,GAAG,YAAY,CAAC,eAAe,CAAC,YAAY,EAAE,UAAU,CAAC,CAAA;IAErF,OAAO,eAAe,CAAA;AAC1B,CAAC;AAED;;;;;GAKG;AACH,MAAM,CAAC,IAAM,0BAA0B,GAAG,UACtC,cAA6B,EAC7B,oBAAsG;IAEtG,IAAM,MAAM,GAAyB;QACjC,qBAAqB,EAAE,qBAAqB,CAAC,qBAAqB;QAClE,6BAA6B,2BAAM,qBAAqB,CAAC,6BAA6B,SAAC;KAC1F,CAAA;IACD,mDAAmD;IACnD,IAAM,gBAAgB,GAClB,cAAc,CAAC,iBAAiB,CAAC,aAAa,KAAK,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,oBAAoB,CAAC,aAAa,CAAA;IACzG,IAAM,aAAa,GACf,cAAc,CAAC,iBAAiB,CAAC,UAAU,KAAK,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,oBAAoB,CAAC,UAAU,CAAA;IACnG,IAAM,oBAAoB,GACtB,cAAc,CAAC,mBAAmB,KAAK,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,oBAAoB,CAAC,iBAAiB,CAAA;IAEjG,IAAM,cAAc,GAAG,gBAAgB,CAAC,MAAM,CAAC,CAAA;IAE/C,IAAM,kBAAkB,GAA0C,UAAC,CAAyB;QACxF,OAAA,cAAc,CAAC,kBAAkB,CAAC,yBAAyB,CAAC,CAAC,CAAC,CAAC,CAAC;IAAhE,CAAgE,CAAA;IAEpE,IAAM,yBAAyB,GAAG,WAAW,CAAC,cAAc,CAAC,iBAAiB,CAAC,oBAAoB,CAAC,CAAA;IAEpG,IAAI,yBAAyB,IAAI,WAAW,CAAC,cAAc,CAAC,iBAAiB,CAAC,4BAA4B,CAAC,EAAE;QACzG,MAAM,CAAC,IAAI,CACP,qHAAqH,CACxH,CAAA;KACJ;IAED,IAAI,yBAAyB,EAAE;QAC3B,cAAc,CAAC,iBAAiB,CAAC,4BAA4B,GAAG,UAAC,IAA4B;YACzF,IAAM,UAAU,GAAG,cAAc,CAAC,iBAAiB,CAAC,oBAAqB,CAAC,EAAE,GAAG,EAAE,IAAI,CAAC,IAAI,EAAE,CAAC,CAAA;YAC7F,OAAO,sBACA,IAAI,KACP,IAAI,EAAE,UAAU,aAAV,UAAU,uBAAV,UAAU,CAAE,GAAG,GACE,CAAA;QAC/B,CAAC,CAAA;KACJ;IAED,MAAM,CAAC,aAAa,GAAG,WAAW,CAAC,cAAc,CAAC,iBAAiB,CAAC,4BAA4B,CAAC;QAC7F,CAAC,CAAC,UAAC,IAAI;;YACD,IAAM,cAAc,GAAG,kBAAkB,CAAC,IAAI,CAAC,CAAA;YAC/C,OAAO,cAAc;gBACjB,CAAC,CAAC,MAAA,MAAA,MAAA,cAAc,CAAC,iBAAiB,EAAC,4BAA4B,mDAAG,cAAc,CAAC,mCAAI,SAAS;gBAC9F,CAAC,CAAC,SAAS,CAAA;QACnB,CAAC;QACH,CAAC,CAAC,UAAC,IAAI,IAAK,OAAA,aAAa,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC,EAAvC,CAAuC,CAAA;IAEvD,sCACO,qBAAqB,GACrB,MAAM,KACT,aAAa,EAAE,gBAAgB,EAC/B,UAAU,EAAE,aAAa,EACzB,iBAAiB,EAAE,oBAAoB,EACvC,qBAAqB,EAAE,oBAAoB,IAC9C;AACL,CAAC,CAAA","sourcesContent":["import { CapturedNetworkRequest, NetworkRecordOptions, PostHogConfig } from '../../types'\nimport { _isFunction, _isNullish, _isString, _isUndefined } from '../../utils/type-utils'\nimport { convertToURL } from '../../utils/request-utils'\nimport { logger } from '../../utils/logger'\nimport { shouldCaptureValue } from '../../autocapture-utils'\nimport { _each } from '../../utils'\n\nconst LOGGER_PREFIX = '[SessionRecording]'\n\nexport const defaultNetworkOptions: NetworkRecordOptions = {\n    initiatorTypes: [\n        'audio',\n        'beacon',\n        'body',\n        'css',\n        'early-hint',\n        'embed',\n        'fetch',\n        'frame',\n        'iframe',\n        'icon',\n        'image',\n        'img',\n        'input',\n        'link',\n        'navigation',\n        'object',\n        'ping',\n        'script',\n        'track',\n        'video',\n        'xmlhttprequest',\n    ],\n    maskRequestFn: (data: CapturedNetworkRequest) => data,\n    recordHeaders: false,\n    recordBody: false,\n    recordInitialRequests: false,\n    recordPerformance: false,\n    performanceEntryTypeToObserve: [\n        // 'event', // This is too noisy as it covers all browser events\n        'first-input',\n        // 'mark', // Mark is used too liberally. We would need to filter for specific marks\n        // 'measure', // Measure is used too liberally. We would need to filter for specific measures\n        'navigation',\n        'paint',\n        'resource',\n    ],\n    payloadSizeLimitBytes: 1000000,\n}\n\nconst HEADER_DENY_LIST = [\n    'authorization',\n    'x-forwarded-for',\n    'authorization',\n    'cookie',\n    'set-cookie',\n    'x-api-key',\n    'x-real-ip',\n    'remote-addr',\n    'forwarded',\n    'proxy-authorization',\n    'x-csrf-token',\n    'x-csrftoken',\n    'x-xsrf-token',\n]\n\nconst PAYLOAD_CONTENT_DENY_LIST = [\n    'password',\n    'secret',\n    'passwd',\n    'api_key',\n    'apikey',\n    'auth',\n    'credentials',\n    'mysql_pwd',\n    'privatekey',\n    'private_key',\n    'token',\n]\n\n// we always remove headers on the deny list because we never want to capture this sensitive data\nconst removeAuthorizationHeader = (data: CapturedNetworkRequest): CapturedNetworkRequest => {\n    _each(Object.keys(data.requestHeaders ?? {}), (header) => {\n        if (HEADER_DENY_LIST.includes(header.toLowerCase())) delete data.requestHeaders?.[header]\n    })\n    return data\n}\n\nconst POSTHOG_PATHS_TO_IGNORE = ['/s/', '/e/', '/i/']\n// want to ignore posthog paths when capturing requests, or we can get trapped in a loop\n// because calls to PostHog would be reported using a call to PostHog which would be reported....\nconst ignorePostHogPaths = (data: CapturedNetworkRequest): CapturedNetworkRequest | undefined => {\n    const url = convertToURL(data.name)\n    if (url && url.pathname && POSTHOG_PATHS_TO_IGNORE.some((path) => url.pathname.indexOf(path) === 0)) {\n        return undefined\n    }\n    return data\n}\n\nfunction estimateBytes(payload: string): number {\n    return new Blob([payload]).size\n}\n\nfunction enforcePayloadSizeLimit(\n    payload: string | null | undefined,\n    headers: Record<string, any> | undefined,\n    limit: number,\n    description: string\n): string | null | undefined {\n    if (_isNullish(payload)) {\n        return payload\n    }\n\n    let requestContentLength: string | number = headers?.['content-length'] || estimateBytes(payload)\n    if (_isString(requestContentLength)) {\n        requestContentLength = parseInt(requestContentLength)\n    }\n\n    if (requestContentLength > limit) {\n        return LOGGER_PREFIX + ` ${description} body too large to record (${requestContentLength} bytes)`\n    }\n\n    return payload\n}\n\n// people can have arbitrarily large payloads on their site, but we don't want to ingest them\nconst limitPayloadSize = (\n    options: NetworkRecordOptions\n): ((data: CapturedNetworkRequest | undefined) => CapturedNetworkRequest | undefined) => {\n    // the smallest of 1MB or the specified limit if there is one\n    const limit = Math.min(1000000, options.payloadSizeLimitBytes ?? 1000000)\n\n    return (data) => {\n        if (data?.requestBody) {\n            data.requestBody = enforcePayloadSizeLimit(data.requestBody, data.requestHeaders, limit, 'Request')\n        }\n\n        if (data?.responseBody) {\n            data.responseBody = enforcePayloadSizeLimit(data.responseBody, data.responseHeaders, limit, 'Response')\n        }\n\n        return data\n    }\n}\n\nfunction scrubPayload(payload: string | null | undefined, label: 'Request' | 'Response'): string | null | undefined {\n    if (_isNullish(payload)) {\n        return payload\n    }\n    let scrubbed = payload\n\n    if (!shouldCaptureValue(scrubbed, false)) {\n        scrubbed = LOGGER_PREFIX + ' ' + label + ' body redacted'\n    }\n    _each(PAYLOAD_CONTENT_DENY_LIST, (text) => {\n        if (scrubbed?.length && scrubbed?.indexOf(text) !== -1) {\n            scrubbed = LOGGER_PREFIX + ' ' + label + ' body redacted as might contain: ' + text\n        }\n    })\n\n    return scrubbed\n}\n\nfunction scrubPayloads(capturedRequest: CapturedNetworkRequest | undefined): CapturedNetworkRequest | undefined {\n    if (_isUndefined(capturedRequest)) {\n        return undefined\n    }\n\n    capturedRequest.requestBody = scrubPayload(capturedRequest.requestBody, 'Request')\n    capturedRequest.responseBody = scrubPayload(capturedRequest.responseBody, 'Response')\n\n    return capturedRequest\n}\n\n/**\n *  whether a maskRequestFn is provided or not,\n *  we ensure that we remove the denied header from requests\n *  we _never_ want to record that header by accident\n *  if someone complains then we'll add an opt-in to let them override it\n */\nexport const buildNetworkRequestOptions = (\n    instanceConfig: PostHogConfig,\n    remoteNetworkOptions: Pick<NetworkRecordOptions, 'recordHeaders' | 'recordBody' | 'recordPerformance'>\n): NetworkRecordOptions => {\n    const config: NetworkRecordOptions = {\n        payloadSizeLimitBytes: defaultNetworkOptions.payloadSizeLimitBytes,\n        performanceEntryTypeToObserve: [...defaultNetworkOptions.performanceEntryTypeToObserve],\n    }\n    // client can always disable despite remote options\n    const canRecordHeaders =\n        instanceConfig.session_recording.recordHeaders === false ? false : remoteNetworkOptions.recordHeaders\n    const canRecordBody =\n        instanceConfig.session_recording.recordBody === false ? false : remoteNetworkOptions.recordBody\n    const canRecordPerformance =\n        instanceConfig.capture_performance === false ? false : remoteNetworkOptions.recordPerformance\n\n    const payloadLimiter = limitPayloadSize(config)\n\n    const enforcedCleaningFn: NetworkRecordOptions['maskRequestFn'] = (d: CapturedNetworkRequest) =>\n        payloadLimiter(ignorePostHogPaths(removeAuthorizationHeader(d)))\n\n    const hasDeprecatedMaskFunction = _isFunction(instanceConfig.session_recording.maskNetworkRequestFn)\n\n    if (hasDeprecatedMaskFunction && _isFunction(instanceConfig.session_recording.maskCapturedNetworkRequestFn)) {\n        logger.warn(\n            'Both `maskNetworkRequestFn` and `maskCapturedNetworkRequestFn` are defined. `maskNetworkRequestFn` will be ignored.'\n        )\n    }\n\n    if (hasDeprecatedMaskFunction) {\n        instanceConfig.session_recording.maskCapturedNetworkRequestFn = (data: CapturedNetworkRequest) => {\n            const cleanedURL = instanceConfig.session_recording.maskNetworkRequestFn!({ url: data.name })\n            return {\n                ...data,\n                name: cleanedURL?.url,\n            } as CapturedNetworkRequest\n        }\n    }\n\n    config.maskRequestFn = _isFunction(instanceConfig.session_recording.maskCapturedNetworkRequestFn)\n        ? (data) => {\n              const cleanedRequest = enforcedCleaningFn(data)\n              return cleanedRequest\n                  ? instanceConfig.session_recording.maskCapturedNetworkRequestFn?.(cleanedRequest) ?? undefined\n                  : undefined\n          }\n        : (data) => scrubPayloads(enforcedCleaningFn(data))\n\n    return {\n        ...defaultNetworkOptions,\n        ...config,\n        recordHeaders: canRecordHeaders,\n        recordBody: canRecordBody,\n        recordPerformance: canRecordPerformance,\n        recordInitialRequests: canRecordPerformance,\n    }\n}\n"]}